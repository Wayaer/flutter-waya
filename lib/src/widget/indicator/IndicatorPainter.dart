import 'package:flutter/material.dart';import 'package:flutter/widgets.dart';import 'package:flutter_waya/src/widget/indicator/Indicator.dart';class WarmPainter extends IndicatorPainter {  WarmPainter(Indicator widget, double page, int index, Paint paint)      : super(widget, page, index, paint);  void draw(Canvas canvas, double space, double size, double radius) {    double progress = page - index;    double distance = size + space;    double start = index * (size + space);    if (progress > 0.5) {      double right = start + size + distance;      //progress=>0.5-1.0      //left:0.0=>distance      double left = index * distance + distance * (progress - 0.5) * 2;      canvas.drawRRect(          RRect.fromLTRBR(              left, 0.0, right, size, Radius.circular(radius)),          _paint);    } else {      double right = start + size + distance * progress * 2;      canvas.drawRRect(          RRect.fromLTRBR(              start, 0.0, right, size, Radius.circular(radius)),          _paint);    }  }}class DropPainter extends IndicatorPainter {  DropPainter(Indicator widget, double page, int index, Paint paint)      : super(widget, page, index, paint);  @override  void draw(Canvas canvas, double space, double size, double radius) {    double progress = page - index;    double dropHeight = widget.dropHeight;    double rate = (0.5 - progress).abs() * 2;    double scale = widget.scale;    //lerp(begin, end, progress)    canvas.drawCircle(        Offset(radius + ((page) * (size + space)),            radius - dropHeight * (1 - rate)),        radius * (scale + rate * (1.0 - scale)),        _paint);  }}class NonePainter extends IndicatorPainter {  NonePainter(Indicator widget, double page, int index, Paint paint)      : super(widget, page, index, paint);  @override  void draw(Canvas canvas, double space, double size, double radius) {    double progress = page - index;    double secondOffset = index == widget.count - 1        ? radius        : radius + ((index + 1) * (size + space));    if (progress > 0.5) {      canvas.drawCircle(Offset(secondOffset, radius), radius, _paint);    } else {      canvas.drawCircle(Offset(radius + (index * (size + space)), radius),          radius, _paint);    }  }}class SlidePainter extends IndicatorPainter {  SlidePainter(Indicator widget, double page, int index, Paint paint)      : super(widget, page, index, paint);  @override  void draw(Canvas canvas, double space, double size, double radius) {    canvas.drawCircle(        Offset(radius + (page * (size + space)), radius), radius, _paint);  }}class ScalePainter extends IndicatorPainter {  ScalePainter(Indicator widget, double page, int index, Paint paint)      : super(widget, page, index, paint);  // 连续的两个点，含有最后一个和第一个  @override  bool _shouldSkip(int i) {    if (index == widget.count - 1) {      return i == 0 || i == index;    }    return (i == index || i == index + 1);  }  @override  void paint(Canvas canvas, Size size) {    _paint.color = widget.color;    double space = widget.space;    double size = widget.size;    double radius = size / 2;    for (int i = 0, c = widget.count; i < c; ++i) {      if (_shouldSkip(i)) {        continue;      }      canvas.drawCircle(Offset(i * (size + space) + radius, radius),          radius * widget.scale, _paint);    }    _paint.color = widget.activeColor;    draw(canvas, space, size, radius);  }  @override  void draw(Canvas canvas, double space, double size, double radius) {    double secondOffset = index == widget.count - 1        ? radius        : radius + ((index + 1) * (size + space));    double progress = page - index;    _paint.color = Color.lerp(widget.activeColor, widget.color, progress);    //last    canvas.drawCircle(Offset(radius + (index * (size + space)), radius),        lerp(radius, radius * widget.scale, progress), _paint);    //first    _paint.color = Color.lerp(widget.color, widget.activeColor, progress);    canvas.drawCircle(Offset(secondOffset, radius),        lerp(radius * widget.scale, radius, progress), _paint);  }}class ColorPainter extends IndicatorPainter {  ColorPainter(Indicator widget, double page, int index, Paint paint)      : super(widget, page, index, paint);  // 连续的两个点，含有最后一个和第一个  @override  bool _shouldSkip(int i) {    if (index == widget.count - 1) {      return i == 0 || i == index;    }    return (i == index || i == index + 1);  }  @override  void draw(Canvas canvas, double space, double size, double radius) {    double progress = page - index;    double secondOffset = index == widget.count - 1        ? radius        : radius + ((index + 1) * (size + space));    _paint.color = Color.lerp(widget.activeColor, widget.color, progress);    //left    canvas.drawCircle(        Offset(radius + (index * (size + space)), radius), radius, _paint);    //right    _paint.color = Color.lerp(widget.color, widget.activeColor, progress);    canvas.drawCircle(Offset(secondOffset, radius), radius, _paint);  }}abstract class IndicatorPainter extends CustomPainter {  final Indicator widget;  final double page;  final int index;  final Paint _paint;  double lerp(double begin, double end, double progress) {    return begin + (end - begin) * progress;  }  IndicatorPainter(this.widget, this.page, this.index, this._paint);  void draw(Canvas canvas, double space, double size, double radius);  bool _shouldSkip(int index) {    return false;  }  //double secondOffset = index == widget.count-1 ? radius : radius + ((index + 1) * (size + space));  @override  void paint(Canvas canvas, Size size) {    _paint.color = widget.color;    double space = widget.space;    double size = widget.size;    double radius = size / 2;    for (int i = 0, c = widget.count; i < c; ++i) {      if (_shouldSkip(i)) {        continue;      }      canvas.drawCircle(          Offset(i * (size + space) + radius, radius), radius, _paint);    }    double page = this.page;    if (page < index) {      page = 0.0;    }    _paint.color = widget.activeColor;    draw(canvas, space, size, radius);  }  @override  bool shouldRepaint(IndicatorPainter oldDelegate) {    return oldDelegate.page != page;  }}